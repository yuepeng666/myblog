<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异步创建加载script]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%BC%82%E6%AD%A5%E5%88%9B%E5%BB%BA%E5%8A%A0%E8%BD%BDscript%2F</url>
    <content type="text"><![CDATA[异步创建加载script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @param &#123;*&#125; url 需要引用的script标签的地址 * @param &#123;*&#125; callback 创建完成script元素回调 * @returns */function createScript(url, callback) &#123; const scriptEl = document.createElement('script'); scriptEl.charset = 'utf-8' scriptEl.src = url; // document.body.appendChild(scriptEl); // 添加到head const head = document.head || document.getElementsByTagName('head')[0]; head.appendChild(scriptEl); const promise = new Promise((resolve, reject) =&gt; &#123; // 不支持ie8及以下 scriptEl.addEventListener( 'load', e =&gt; &#123; if (!callback) &#123; resolve(e); &#125; else &#123; callback() resolve(e); &#125; &#125;, false ); scriptEl.addEventListener( 'error', e =&gt; &#123; removeScript(scriptEl) reject(e); &#125;, false ); &#125;); return promise;&#125;/** * 移除script标签 * @param scriptEl script dom */function removeScript(scriptEl) &#123; document.body.removeChild(scriptEl);&#125;export default createScript;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss一些笔记]]></title>
    <url>%2F2019%2F10%2F14%2Fscss%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[scss for循环1234567$color-list: #5e83fb, #f7da47, #58ca9a, #ee706d, #ffa502, #808e9b;@for $i from 1 to 7 &#123; .grid-#&#123;$i&#125; &#123; background-color: nth($color-list, $i); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue cli 引入cdn加速]]></title>
    <url>%2F2019%2F10%2F14%2Fvue-cli-%E5%BC%95%E5%85%A5cdn%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[vue.config.js 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128const path = require('path');const TerserPlugin = require('terser-webpack-plugin');const vueV = require('vue/package.json').version;const routerV = require('vue-router/package.json').version;const vuexV = require('vuex/package.json').version;const axiosV = require('axios/package.json').version;const elementV = require('element-ui/package.json').version;const cookieV = require('js-cookie/package.json').version;const nprogressV = require('nprogress/package.json').version;const echartsV = require('echarts/package.json').version;const isProduction = process.env.NODE_ENV === 'production';const isCdn = true; // 是否开启cdn模式const logTxt = process.env.NODE_ENV === 'development' ? '编译开发' : process.env.VUE_APP_FLAG === 'test' ? '打包测试' : '打包线上';console.log(logTxt);function resolve(dir) &#123; return path.join(__dirname, dir)&#125;// 需要忽略打包的 npm包const Externals = &#123; 'vue': 'Vue', 'vuex': 'Vuex', 'vue-router': 'VueRouter', 'axios': 'axios', 'element-ui': 'ELEMENT', 'js-cookie': 'Cookies', 'nprogress': 'NProgress', 'echarts': 'echarts', &#125;;// cdn地址const CDN = &#123; css: [ // `https://cdn.jsdelivr.net/npm/element-ui@$&#123;elementV&#125;/lib/theme-chalk/index.min.css`, `https://cdn.bootcss.com/element-ui/$&#123;elementV&#125;/theme-chalk/index.css`, `https://cdn.bootcss.com/nprogress/$&#123;nprogressV&#125;/nprogress.min.css`, ], js: [ // `https://cdn.jsdelivr.net/npm/vue@$&#123;vueV&#125;/dist/vue.min.js`, // `https://cdn.jsdelivr.net/npm/vuex@$&#123;vuexV&#125;/dist/vuex.min.js`, // `https://cdn.jsdelivr.net/npm/vue-router@$&#123;routerV&#125;/dist/vue-router.min.js`, `https://cdn.bootcss.com/vue/$&#123;vueV&#125;/vue.min.js`, `https://cdn.bootcss.com/vuex/$&#123;vuexV&#125;/vuex.min.js`, `https://cdn.bootcss.com/vue-router/$&#123;routerV&#125;/vue-router.min.js`, // 从jsdeliver 引入完整element-ui // `https://cdn.jsdelivr.net/npm/element-ui@/$&#123;elementV&#125;/lib/index.min.js`, // 从bootcdn `https://cdn.bootcss.com/element-ui/$&#123;elementV&#125;/index.js`, `https://cdn.bootcss.com/echarts/$&#123;echartsV&#125;/echarts.min.js`, `https://cdn.bootcss.com/axios/$&#123;axiosV&#125;/axios.min.js`, `https://cdn.bootcss.com/js-cookie/$&#123;cookieV&#125;/js.cookie.min.js`, `https://cdn.bootcss.com/nprogress/$&#123;nprogressV&#125;/nprogress.min.js`, ]&#125;;module.exports = &#123; publicPath: '/', // 公共路径 outputDir: process.env.VUE_APP_FLAG === 'test' ? 'test-dist' : 'dist', // 不同的环境打不同包名 lintOnSave: false, // 关闭eslint productionSourceMap: false, // 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建 parallel: require('os').cpus().length &gt; 1, // 构建时开启多进程处理babel编译 // 这里写loader chainWebpack: (config) =&gt; &#123; // production打包才使用CDN if (isProduction &amp;&amp; isCdn) &#123; config.plugin('html') .tap(args =&gt; &#123; args[0].cdn = CDN; return args; &#125;) &#125; // config.resolve.alias // .set('assets', resolve('src/assets')) // .set('pages', resolve('src/pages')) // .set('components', resolve('src/components')) // .set('utils', resolve('src/utils')) &#125;, // 这里回覆盖webpack默认配置 configureWebpack: config =&gt; &#123; // production模式 if (isProduction &amp;&amp; isCdn) &#123; // 忽略的包 config.externals = Externals // 打包生产.gz包 // config.plugins.push(new CompressionWebpackPlugin(&#123; // algorithm: 'gzip', // test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'), // threshold: 10240, // minRatio: 0.8 // &#125;)) // 添加自定义代码压缩配置 config.plugins.push( new TerserPlugin(&#123; // 是否开启多线程 parallel: true, terserOptions: &#123; // 去除打印 compress: &#123; warnings: false, drop_console: true, drop_debugger: true, pure_funcs: ['console.log'] &#125;, // 去除注释，当设置为true时，会保留注释 // 当然这个默认是false output: &#123; comments: false, &#125;, &#125;, &#125;), ) &#125; &#125;&#125;;]]></content>
      <categories>
        <category>vue webpack vue-cli</category>
      </categories>
      <tags>
        <tag>vue webpack vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F25%2FTypeScript%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718interface SquareConfig &#123; color?: string; width?: number;&#125;// ()后面的冒号规定的是返回值的类型function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: "white", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: "black"&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到GitHub并添加个人域名]]></title>
    <url>%2F2019%2F06%2F14%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[域名 从freenom获取免费域名 添加域名解析: 点击 ManageDomain&gt;&gt; ManageTools &gt;&gt; Nameservers 在图示位置添加域名解析服务（本文使用 DnsPod 做域名解析） 123f1g1ns1.dnspod.netf1g1ns2.dnspod.net 注册并登陆 DnsPod, 点击添加域名添加你申请的域名，点击已域名，随后点击添加记录 主机记录：@， 记录类型： A，记录值： （ping 你的 github 账号获到取的 ip） ping githubname.github.io 主机记录：www， 记录类型：CNAME，记录值：yourgithubname.github.io 其他操作如图 绑定域名 在 hexo/source/目录下新建 CNAME 文件(必须大写) 打开 CNAME 文件在里面填入你获取到的域名 打开编辑_config.yml 在图示位置添加你的 github 项目地址 运行如下命令部署 blog 到 github hexo clean hexo d 打开 github 项目进行如下操作 完成]]></content>
      <categories>
        <category>hexo 随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的组件库]]></title>
    <url>%2F2019%2F06%2F03%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[进度条库’nprogress’]]></content>
  </entry>
  <entry>
    <title><![CDATA[React学习记录]]></title>
    <url>%2F2019%2F04%2F19%2FReact%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[运行yarn eject出现问题解决：运行`npm install`, 或者删除node_modules后重新运行 `npm/cnpm install` React配置文件释放后按需导入antd在运行yarn eject 后按需导入antd: 运行 yarn add babel-plugin-import 在package.json中添加 1234567891011121314"babel": &#123; "presets": [ "react-app" ], "plugins": [ [ "import", &#123; "libraryName": "antd", "style": "css" &#125; ] ]&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[饿了么demo的一些笔记]]></title>
    <url>%2F2019%2F03%2F12%2F%E9%A5%BF%E4%BA%86%E4%B9%88demo%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[饿了么demo的一些笔记 1.取得对象key相同的value和 例： 123456789101112131415161718192021var arr = [ &#123; id: 'a', num: 2 &#125;, &#123; id: 'a', num: 2 &#125;, &#123; id: 'a', num: 2 &#125;, &#123; id: 'b', num: 8 &#125;]var newarr = &#123;a:6, b:8&#125;// 代码实现let obj = &#123;&#125;;for (const item of arr) &#123; let [ id, num ] = [ item.id, item.num]; /* hasOwnProperty() 判断对象是否拥有某属性 */ if(obj.hasOwnProperty(id))&#123; obj[id] += num; &#125;else&#123; obj[id] = num; &#125;&#125;console.log(obj) 把对象存进数组，如果存在相同id则数量加1（购物车） 123456789101112let shopcar = [];let flag = false;shopcar.some(item =&gt; &#123; if (item.id === val.id) &#123; item.quantity += 1 flag = true return true &#125;&#125;)if (!flag) &#123; state.shopcar.push(val)&#125;]]></content>
      <tags>
        <tag>vue JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现组件按需加载]]></title>
    <url>%2F2019%2F02%2F26%2FVue%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Vue实现组件按需加载]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中跳转页面返回原页面回到记忆位置]]></title>
    <url>%2F2019%2F02%2F26%2FVue%E4%B8%AD%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%8E%9F%E9%A1%B5%E9%9D%A2%E5%9B%9E%E5%88%B0%E8%AE%B0%E5%BF%86%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Vue中跳转页面返回原页面回到记忆位置 修改 router-view 12345678910&lt;transition name="router-fade" mode="out-in"&gt; // 在这里显示被缓存的页面 &lt;keep-alive&gt; &lt;router-view v-if="$route.meta.keepAlive"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt;&lt;transition name="router-fade" mode="out-in"&gt; // 在这里显示不需要被缓存的页面 &lt;router-view v-if="!$route.meta.keepAlive"&gt;&lt;/router-view&gt;&lt;/transition&gt; 修改vueRouter的配置文件index.js 123456789101112131415161718192021// &#123; path: '/home', name: 'home', component: home, meta: &#123; title: 'home', keepAlive: true // 需要被缓存 &#125;&#125;,// mode: 'history', // vueRouter默认为hash模式scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; else &#123; if (from.meta.keepAlive) &#123; from.meta.savedPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; &#125; return &#123; x: 0, y: to.meta.savedPosition ||0&#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript防抖函数与节流函数]]></title>
    <url>%2F2019%2F02%2F04%2FJavaScript%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[DOM 操作是非常耗费性能的，如果在监听中，做了一些 DOM 操作，那无疑会给浏览器造成大量性能损失，我们可以通过一些操作来减少 DOM 操作 防抖函数定义：函数调用 n 秒后才会执行，如果函 数在 n 秒内被调用的话则函数不执行，重新计算执行时间(规定一定时间内，时间触发的次数)123456789//var timer = false;window.onscroll = () =&gt; &#123; // 函数防抖 clearTimeout(timer); // 清除未执行的代码，重置回初始化状态 timer = setTimeout(function() &#123; console.log("函数防抖"); &#125;, 300);&#125;; 防抖函数封装123456789101112/**防抖函数封装**/function debounce(method, delay) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; method.apply(context, args); &#125;, delay); &#125;;&#125; 节流函数定义：触发函数事件后，短时间间隔内无法连续调用，只有上一次函数执行后，过了规定的时间间隔，才能进行下一次的函数调用（只允许一个函数在 X 毫秒内执行一次）。12345678910111213141516// 函数节流var canRun = true;window.onscroll = () =&gt; &#123; if (!canRun) &#123; // 判断是否已空闲，如果在执行中，则直接return return; &#125; canRun = false; var timer = setTimeout(() =&gt; &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log("滚动位置：" + scrollTop); canRun = true; &#125;, 1000);&#125;;//只有当 canRun 为 ture 时才可执行，当执行完毕时 释放当前任务，允许下一个任务执行]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的slot内容分发]]></title>
    <url>%2F2019%2F02%2F04%2FVue%E7%9A%84slot%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[单个 slot在 children 这个标签里放 Dom，Vue 不会显示，类似于 React 1234567891011//父&lt;children&gt;&lt;span&gt;12345&lt;/span&gt;//这边不会显示&lt;/children&gt;//子components: &#123;children: &#123; template: "&lt;button&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;" &#125;&#125; 你需要写成这个样子 123children: &#123; template: "&lt;button&gt;&lt;slot&gt;&lt;/slot&gt;为了明确作用范围，所以使用button标签&lt;button&gt;"&#125; 可以给 slot 添加属性 1234567891011121314 //父&lt;children&gt; &lt;span slot="name1"&gt;12345&lt;/span&gt;&lt;/children&gt;//子components: &#123; children: &#123; template: "&lt;button&gt; &lt;slot name="name1"&gt;&lt;/slot&gt; button标签 &lt;/button&gt;" &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
